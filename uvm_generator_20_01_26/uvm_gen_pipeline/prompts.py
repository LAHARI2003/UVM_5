"""
Prompt templates for UVM code generation.
Contains all LLM prompts organized by generation phase.
"""

# =============================================================================
# PHASE A: IP Infrastructure Prompts
# =============================================================================

INTERFACE_GENERATION_PROMPT = """Generate a SystemVerilog interface file for the {block_name} DUT.

Block Configuration:
- Block Name: {block_name}
- Clock: {clock_name} ({clock_freq})
- Reset: {reset_name} (Active {reset_polarity})

The interface should include:
1. Clock and reset inputs
2. Control signals for the DUT operation
3. Status/flag signals from DUT
4. A clocking block for synchronous access
5. Initial block with default values

Interfaces to coordinate with:
{interface_list}

Follow the exact style of the example interface provided.
Generate the complete interface file named: {output_filename}
"""

VIRTUAL_SEQUENCER_PROMPT = """Generate a virtual sequencer for the {block_name} UVM environment.

The virtual sequencer should have handles to these sequencers:
{sequencer_list}

Include:
1. `uvm_component_utils` macro
2. All sequencer handles with proper parameterization
3. Virtual interface handle for the main DUT interface
4. build_phase to get the virtual interface from config_db
5. Proper constructor

Follow the exact style of the example virtual sequencer provided.
Generate the complete file named: {output_filename}
"""

ENVIRONMENT_PROMPT = """Generate the top-level UVM environment for {block_name}.

Sub-environments to instantiate:
{env_list}

The environment should:
1. Instantiate all sub-environments listed above
2. Create a virtual sequencer
3. Create a scoreboard (if needed)
4. Get all virtual interfaces from config_db in build_phase
5. Connect sequencers to virtual sequencer in connect_phase
6. Connect interfaces to agents and drivers in connect_phase
7. Connect monitor analysis ports to scoreboard

Use the exact parameter values from the configuration:
{params_config}

Follow the exact style of the example environment provided.
Generate the complete file named: {output_filename}
"""

SCOREBOARD_PROMPT = """Generate a UVM scoreboard for {block_name}.

The scoreboard should:
1. Compare DUT output against expected values from C model
2. Support reading expected output from file (generated by C model)
3. Have analysis imp ports for receiving transactions from monitors
4. Implement the write() method for comparison
5. Track pass/fail statistics
6. Report results in report_phase

Output format from C model:
- File: {expected_output_file}
- Data width: {data_width} bits
- Number of entries: {num_entries}

Follow the exact style and methodology of existing UVM scoreboards.
Generate the complete file named: {output_filename}
"""

# =============================================================================
# PHASE B: Test Case Generation Prompts
# =============================================================================

TEST_FILE_PROMPT = """Generate a UVM test file for test case: {tc_id}

Test Configuration:
- Test ID: {tc_id}
- Environment class: {env_class}
- Virtual sequence class: {vseq_class}

IMPORTANT: Use the EXACT class names and interface types from the infrastructure context provided.
- The environment class name MUST match what's defined in the generated environment file
- The virtual interface type MUST match the generated interface
- The virtual sequencer handle (v_seqr) MUST be used to start the virtual sequence

The test should:
1. Extend uvm_test
2. Create the environment instance using the exact environment class name from context
3. Create the virtual sequence instance  
4. Get the main virtual interface from config_db (use the exact interface type from context)
5. In run_phase:
   - Raise objection
   - Wait for reset deassertion
   - Add initial delay cycles
   - Start the virtual sequence on the environment's virtual sequencer (env.v_seqr)
   - Add final delay cycles
   - Drop objection

Active UVCs for this test:
{active_uvcs}

Follow the exact style of the example test file provided.
Use the exact class names, interface types, and sequencer handles from the infrastructure context.
Generate the complete file named: {output_filename}
"""

VIRTUAL_SEQUENCE_PROMPT = """Generate a virtual sequence for test case: {tc_id}

Test Configuration:
{test_config}

Register Configuration (pack into 32-bit register):
{register_config}

Stimulus Configuration:
{stimulus_config}

CRITICAL: Use the EXACT sequencer handle names from the virtual sequencer in the infrastructure context.
Look at the virtual sequencer class definition to find:
- The correct p_sequencer type to use with `uvm_declare_p_sequencer`
- The exact names of sequencer handles (e.g., seqr_feature_buffer, seqr_kernel_mem, seqr_register, etc.)
- The virtual interface signals available (e.g., vif.dimc_tilewrap_clk, vif.psout_buff_full)

The virtual sequence should:
1. Extend uvm_sequence
2. Use `uvm_declare_p_sequencer` with the EXACT virtual sequencer type from context
3. Declare all needed sub-sequences based on active UVCs
4. Include parameters: mode, sign_8b, PS_FIRST, PS_MODE, PS_LAST, etc.
5. Implement pack_register() helper function with the register bit mapping
6. In body() task:
   a. Set parameter values for this specific test case
   b. Call Python scripts to generate test data (use $system)
   c. Run C model to generate expected output (use $system)
   d. Configure capture signals on virtual interface (use p_sequencer.vif.*)
   e. Run initialization register sequence on p_sequencer.seqr_register
   f. Run input data sequences on correct sequencer handles from p_sequencer
   g. Run start compute register sequence
   h. Wait for completion (poll status signals via p_sequencer.vif)
   i. Run output read sequence on correct output sequencer handle
   j. Cleanup temporary files

Sequences to use:
{sequence_list}

IMPORTANT: Match the sequencer handle names EXACTLY as defined in the virtual sequencer class.
For example, if virtual sequencer has "seqr_register", use "p_sequencer.seqr_register".

Follow the exact style of the example virtual sequence provided.
Generate the complete file named: {output_filename}
"""

# =============================================================================
# PHASE C: Package & Integration Prompts
# =============================================================================

PACKAGE_PROMPT = """Generate a SystemVerilog package file for {block_name}.

The package should import/include:
1. uvm_pkg
2. All UVC packages used:
{uvc_packages}

3. All generated files in order (dependencies first):
{file_list}

Follow standard UVM package structure.
Generate the complete file named: {output_filename}
"""

TESTBENCH_PROMPT = """Generate the top-level testbench module for {block_name}.

The testbench should:
1. Import uvm_pkg and the block package
2. Define parameters for data widths
3. Generate clock and reset
4. Instantiate all interfaces:
{interface_instances}

5. Add register decode logic if using packed registers
6. Instantiate the DUT with proper port connections:
{dut_connections}

7. In initial block:
   - Set all virtual interfaces in uvm_config_db
   - Call run_test()

Follow the exact style of the example testbench provided.
Generate the complete file named: {output_filename}
"""

# =============================================================================
# Utility function to format prompts
# =============================================================================

def format_prompt(template: str, **kwargs) -> str:
    """Format a prompt template with the given arguments."""
    return template.format(**kwargs)


def build_context(
    block_config: dict,
    uvc_mapping: dict,
    model_info: dict = None
) -> str:
    """Build context string for LLM from parsed configurations."""
    context_parts = []
    
    context_parts.append("=== Block Configuration ===")
    context_parts.append(f"Block Name: {block_config.get('name', 'UNKNOWN')}")
    context_parts.append(f"Clock: {block_config.get('clock_name', 'clk')}")
    context_parts.append(f"Reset: {block_config.get('reset_name', 'resetn')}")
    
    context_parts.append("\n=== Interface Mapping ===")
    for iface_name, iface_info in uvc_mapping.get('uvcs', {}).items():
        context_parts.append(f"- {iface_name}: {iface_info.get('kind', '')}")
        if iface_info.get('params'):
            context_parts.append(f"  Params: {iface_info['params']}")
    
    if model_info:
        context_parts.append("\n=== C Model Information ===")
        context_parts.append(f"Arguments: {model_info.get('arg_names', [])}")
        context_parts.append(f"Input files: {model_info.get('input_files', [])}")
        context_parts.append(f"Output files: {model_info.get('output_files', [])}")
        context_parts.append(f"Parameters: {model_info.get('parameters', [])}")
    
    return '\n'.join(context_parts)


def build_infra_context(infra_files: list) -> str:
    """Build context string from Phase A infrastructure files.
    
    This function reads the generated infrastructure files (environment, virtual sequencer,
    interface, scoreboard) and formats them as context for the LLM to use when generating
    test cases. This ensures test files reference the correct class names, sequencer handles,
    and interface signals.
    
    Args:
        infra_files: List of Path objects pointing to generated infrastructure files
        
    Returns:
        Formatted context string containing infrastructure code
    """
    from pathlib import Path
    
    if not infra_files:
        return ""
    
    context_parts = []
    context_parts.append("=== Generated IP Infrastructure (Phase A) ===")
    context_parts.append("Use these exact class names, sequencer handles, and interface signals in the test and vseq files.\n")
    
    # Categorize files for structured context
    env_files = []
    vseqr_files = []
    interface_files = []
    scoreboard_files = []
    other_files = []
    
    for file_path in infra_files:
        if not isinstance(file_path, Path):
            file_path = Path(file_path)
        
        if not file_path.exists():
            continue
            
        name_lower = file_path.name.lower()
        if 'env' in name_lower:
            env_files.append(file_path)
        elif 'virtual_sequencer' in name_lower or 'vseqr' in name_lower:
            vseqr_files.append(file_path)
        elif 'interface' in name_lower or '_if' in name_lower:
            interface_files.append(file_path)
        elif 'scoreboard' in name_lower:
            scoreboard_files.append(file_path)
        else:
            other_files.append(file_path)
    
    # Add virtual sequencer first (most important for test/vseq generation)
    for file_path in vseqr_files:
        content = file_path.read_text()
        context_parts.append(f"\n--- Virtual Sequencer ({file_path.name}) ---")
        context_parts.append("IMPORTANT: Use these exact sequencer handle names in the vseq body() task:")
        context_parts.append(content)
    
    # Add environment (shows how sub-environments are instantiated)
    for file_path in env_files:
        content = file_path.read_text()
        context_parts.append(f"\n--- Environment ({file_path.name}) ---")
        context_parts.append("IMPORTANT: Use this exact environment class name in the test file:")
        context_parts.append(content)
    
    # Add interface (shows available signals)
    for file_path in interface_files:
        content = file_path.read_text()
        context_parts.append(f"\n--- Interface ({file_path.name}) ---")
        context_parts.append("Available signals for the virtual interface:")
        context_parts.append(content)
    
    # Add scoreboard if present
    for file_path in scoreboard_files:
        content = file_path.read_text()
        context_parts.append(f"\n--- Scoreboard ({file_path.name}) ---")
        context_parts.append(content)
    
    # Add any other infrastructure files
    for file_path in other_files:
        content = file_path.read_text()
        context_parts.append(f"\n--- {file_path.name} ---")
        context_parts.append(content)
    
    return '\n'.join(context_parts)