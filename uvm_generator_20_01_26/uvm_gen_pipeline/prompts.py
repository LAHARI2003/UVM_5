"""
Prompt templates for UVM code generation.
Contains all LLM prompts organized by generation phase.
"""

# =============================================================================
# PHASE A: IP Infrastructure Prompts
# =============================================================================

INTERFACE_GENERATION_PROMPT = """Generate a SystemVerilog interface file for the {block_name} DUT.

Block Configuration:
- Block Name: {block_name}
- Clock: {clock_name} ({clock_freq})
- Reset: {reset_name} (Active {reset_polarity})

The interface should include:
1. Clock and reset inputs
2. Control signals for the DUT operation
3. Status/flag signals from DUT
4. A clocking block for synchronous access
5. Initial block with default values

Interfaces to coordinate with:
{interface_list}

Follow the exact style of the example interface provided.
Generate the complete interface file named: {output_filename}
"""

VIRTUAL_SEQUENCER_PROMPT = """Generate a virtual sequencer for the {block_name} UVM environment.

The virtual sequencer should have handles to these sequencers:
{sequencer_list}

Include:
1. `uvm_component_utils` macro
2. All sequencer handles with proper parameterization
3. Virtual interface handle for the main DUT interface
4. build_phase to get the virtual interface from config_db
5. Proper constructor

Follow the exact style of the example virtual sequencer provided.
Generate the complete file named: {output_filename}
"""

ENVIRONMENT_PROMPT = """Generate the top-level UVM environment for {block_name}.

Sub-environments to instantiate:
{env_list}

The environment should:
1. Instantiate all sub-environments listed above
2. Create a virtual sequencer
3. Create a scoreboard (if needed)
4. Get all virtual interfaces from config_db in build_phase
5. Connect sequencers to virtual sequencer in connect_phase
6. Connect interfaces to agents and drivers in connect_phase
7. Connect monitor analysis ports to scoreboard

Use the exact parameter values from the configuration:
{params_config}

Follow the exact style of the example environment provided.
Generate the complete file named: {output_filename}
"""

SCOREBOARD_PROMPT = """Generate a UVM scoreboard for {block_name}.

The scoreboard should:
1. Compare DUT output against expected values from C model
2. Support reading expected output from file (generated by C model)
3. Have analysis imp ports for receiving transactions from monitors
4. Implement the write() method for comparison
5. Track pass/fail statistics
6. Report results in report_phase

Output format from C model:
- File: {expected_output_file}
- Data width: {data_width} bits
- Number of entries: {num_entries}

Follow the exact style and methodology of existing UVM scoreboards.
Generate the complete file named: {output_filename}
"""

# =============================================================================
# PHASE B: Test Case Generation Prompts
# =============================================================================

TEST_FILE_PROMPT = """Generate a UVM test file for test case: {tc_id}

Test Configuration:
- Test ID: {tc_id}
- Environment class: {env_class}
- Virtual sequence class: {vseq_class}

The test should:
1. Extend uvm_test
2. Create the environment instance
3. Create the virtual sequence instance
4. Get the main virtual interface from config_db
5. In run_phase:
   - Raise objection
   - Wait for reset deassertion
   - Add initial delay cycles
   - Start the virtual sequence on the environment's virtual sequencer
   - Add final delay cycles
   - Drop objection

Active UVCs for this test:
{active_uvcs}

Follow the exact style of the example test file provided.
Generate the complete file named: {output_filename}
"""

VIRTUAL_SEQUENCE_PROMPT = """Generate a virtual sequence for test case: {tc_id}

Test Configuration:
{test_config}

Register Configuration (pack into 32-bit register):
{register_config}

Stimulus Configuration:
{stimulus_config}

The virtual sequence should:
1. Extend uvm_sequence
2. Use `uvm_declare_p_sequencer` with the virtual sequencer type
3. Declare all needed sub-sequences based on active UVCs
4. Include parameters: mode, sign_8b, PS_FIRST, PS_MODE, PS_LAST, etc.
5. Implement pack_register() helper function with the register bit mapping
6. In body() task:
   a. Set parameter values for this specific test case
   b. Call Python scripts to generate test data (use $system)
   c. Run C model to generate expected output (use $system)
   d. Configure capture signals on virtual interface
   e. Run initialization register sequence
   f. Run input data sequences (feature, kernel, psin, addin as needed)
   g. Run start compute register sequence
   h. Wait for completion (poll status signals)
   i. Run output read sequence
   j. Cleanup temporary files

Sequences to use:
{sequence_list}

Follow the exact style of the example virtual sequence provided.
Generate the complete file named: {output_filename}
"""

# =============================================================================
# PHASE C: Package & Integration Prompts
# =============================================================================

PACKAGE_PROMPT = """Generate a SystemVerilog package file for {block_name}.

The package should import/include:
1. uvm_pkg
2. All UVC packages used:
{uvc_packages}

3. All generated files in order (dependencies first):
{file_list}

Follow standard UVM package structure.
Generate the complete file named: {output_filename}
"""

TESTBENCH_PROMPT = """Generate the top-level testbench module for {block_name}.

The testbench should:
1. Import uvm_pkg and the block package
2. Define parameters for data widths
3. Generate clock and reset
4. Instantiate all interfaces:
{interface_instances}

5. Add register decode logic if using packed registers
6. Instantiate the DUT with proper port connections:
{dut_connections}

7. In initial block:
   - Set all virtual interfaces in uvm_config_db
   - Call run_test()

Follow the exact style of the example testbench provided.
Generate the complete file named: {output_filename}
"""

# =============================================================================
# Utility function to format prompts
# =============================================================================

def format_prompt(template: str, **kwargs) -> str:
    """Format a prompt template with the given arguments."""
    return template.format(**kwargs)


def build_context(
    block_config: dict,
    uvc_mapping: dict,
    model_info: dict = None
) -> str:
    """Build context string for LLM from parsed configurations."""
    context_parts = []
    
    context_parts.append("=== Block Configuration ===")
    context_parts.append(f"Block Name: {block_config.get('name', 'UNKNOWN')}")
    context_parts.append(f"Clock: {block_config.get('clock_name', 'clk')}")
    context_parts.append(f"Reset: {block_config.get('reset_name', 'resetn')}")
    
    context_parts.append("\n=== Interface Mapping ===")
    for iface_name, iface_info in uvc_mapping.get('uvcs', {}).items():
        context_parts.append(f"- {iface_name}: {iface_info.get('kind', '')}")
        if iface_info.get('params'):
            context_parts.append(f"  Params: {iface_info['params']}")
    
    if model_info:
        context_parts.append("\n=== C Model Information ===")
        context_parts.append(f"Arguments: {model_info.get('arg_names', [])}")
        context_parts.append(f"Input files: {model_info.get('input_files', [])}")
        context_parts.append(f"Output files: {model_info.get('output_files', [])}")
        context_parts.append(f"Parameters: {model_info.get('parameters', [])}")
    
    return '\n'.join(context_parts)
