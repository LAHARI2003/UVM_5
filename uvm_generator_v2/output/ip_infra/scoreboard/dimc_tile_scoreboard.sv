//==============================================================================
// File: dimc_tile_scoreboard.sv
// Auto-generated by UVM Generator V2
// Generated: 2026-01-20 00:09:15
// 
// WARNING: This file is auto-generated. Manual changes may be overwritten.
//==============================================================================

package dimc_tile_scoreboard_pkg;

  import uvm_pkg::*;
  `include "uvm_macros.svh"

  class dimc_tile_scoreboard extends uvm_scoreboard;
    `uvm_component_utils(dimc_tile_scoreboard)

    typedef logic [63:0] data64_t;
    typedef logic [31:0] data32_t;

    // Analysis imps (inputs for reference context; output for checking)
    uvm_analysis_imp#(data64_t, dimc_tile_scoreboard) m_output_buffer_env_imp;
    uvm_analysis_imp#(data64_t, dimc_tile_scoreboard) m_feature_buffer_env_imp;
    uvm_analysis_imp#(data32_t, dimc_tile_scoreboard) m_psin_env_imp;
    uvm_analysis_imp#(data64_t, dimc_tile_scoreboard) m_kernel_mem_env_imp;
    uvm_analysis_imp#(data64_t, dimc_tile_scoreboard) m_addin_env_imp;

    // Expected data storage
    data64_t expected_q[$];
    int unsigned expected_loaded = 0;

    // Optional: store last-seen input samples for debug correlation
    data64_t feature_q[$];
    data32_t psin_q[$];
    data64_t kernel_q[$];
    data64_t addin_q[$];

    // Statistics
    longint unsigned total_compares = 0;
    longint unsigned matches = 0;
    longint unsigned mismatches = 0;
    longint unsigned extra_actual = 0;
    longint unsigned missing_expected = 0;

    // Configuration
    string expected_file = "";
    bit strict_expected = 1; // if 1, errors when actual arrives with no expected

    function new(string name="dimc_tile_scoreboard", uvm_component parent=null);
      super.new(name, parent);
    endfunction

    function void build_phase(uvm_phase phase);
      super.build_phase(phase);

      m_output_buffer_env_imp  = new("m_output_buffer_env_imp",  this);
      m_feature_buffer_env_imp = new("m_feature_buffer_env_imp", this);
      m_psin_env_imp           = new("m_psin_env_imp",          this);
      m_kernel_mem_env_imp     = new("m_kernel_mem_env_imp",    this);
      m_addin_env_imp          = new("m_addin_env_imp",         this);

      void'(uvm_config_db#(string)::get(this, "", "expected_file", expected_file));
      void'(uvm_config_db#(bit)::get(this, "", "strict_expected", strict_expected));
    endfunction

    function void start_of_simulation_phase(uvm_phase phase);
      super.start_of_simulation_phase(phase);
      if (expected_file != "") begin
        if (!load_expected_from_file(expected_file)) begin
          `uvm_error(get_type_name(), $sformatf("Failed to load expected data from file: '%0s'", expected_file))
        end
        else begin
          `uvm_info(get_type_name(), $sformatf("Loaded %0d expected output words from '%0s'", expected_loaded, expected_file), UVM_LOW)
        end
      end
      else begin
        `uvm_warning(get_type_name(), "No expected_file configured; scoreboard will compare only against any expected pushed at runtime (if any).")
      end
    endfunction

    // Load expected data from file (one 64b word per line; supports hex with/without 0x, or binary)
    function bit load_expected_from_file(string fname);
      int fd;
      string line;
      data64_t val;
      int n;
      expected_q.delete();
      expected_loaded = 0;

      fd = $fopen(fname, "r");
      if (fd == 0) return 0;

      while (!$feof(fd)) begin
        line = "";
        void'($fgets(line, fd));

        // Strip comments starting with // or #
        line = strip_comment(line);

        // Trim whitespace
        line = trim(line);

        if (line.len() == 0) continue;

        val = '0;
        n = $sscanf(line, "%h", val);
        if (n != 1) begin
          // Try binary
          n = $sscanf(line, "%b", val);
        end

        if (n != 1) begin
          `uvm_warning(get_type_name(), $sformatf("Skipping unparsable line in expected file '%0s': %0s", fname, line))
          continue;
        end

        expected_q.push_back(val);
        expected_loaded++;
      end

      $fclose(fd);
      return 1;
    endfunction

    // Public method to push expected dynamically
    function void push_expected(data64_t exp);
      expected_q.push_back(exp);
      expected_loaded++;
    endfunction

    // ---- write() overloads for different analysis imps ----

    // Actual output checking
    function void write(data64_t t);
      data64_t exp;

      total_compares++;

      if (expected_q.size() == 0) begin
        extra_actual++;
        if (strict_expected) begin
          `uvm_error(get_type_name(),
                     $sformatf("Actual output arrived but no expected data available. actual=0x%016h (total_compares=%0d)", t, total_compares))
        end
        else begin
          `uvm_warning(get_type_name(),
                       $sformatf("Actual output arrived but no expected data available. actual=0x%016h (total_compares=%0d)", t, total_compares))
        end
        return;
      end

      exp = expected_q.pop_front();

      if (t === exp) begin
        matches++;
      end
      else begin
        mismatches++;
        `uvm_error(get_type_name(),
                   $sformatf("Mismatch at compare #%0d: expected=0x%016h actual=0x%016h (expected_remaining=%0d)",
                             total_compares, exp, t, expected_q.size()))
      end
    endfunction

    // Feature input capture
    function void write_feature(data64_t t);
      feature_q.push_back(t);
    endfunction

    // psin input capture
    function void write_psin(data32_t t);
      psin_q.push_back(t);
    endfunction

    // kernel input capture
    function void write_kernel(data64_t t);
      kernel_q.push_back(t);
    endfunction

    // addin input capture
    function void write_addin(data64_t t);
      addin_q.push_back(t);
    endfunction

    // ---- Bind the write_* to the proper analysis_imp via specialized classes ----
    // Use small wrapper imps to route to distinct methods without relying on uvm_analysis_imp_decl.
    class data64_imp extends uvm_analysis_imp#(data64_t, dimc_tile_scoreboard);
      typedef enum int {OUT=0, FEATURE=1, KERNEL=2, ADDIN=3} kind_e;
      kind_e kind;
      function new(string name, dimc_tile_scoreboard parent, kind_e k);
        super.new(name, parent);
        kind = k;
      endfunction
      virtual function void write(data64_t t);
        case (kind)
          OUT:     m_parent.write(t);
          FEATURE: m_parent.write_feature(t);
          KERNEL:  m_parent.write_kernel(t);
          ADDIN:   m_parent.write_addin(t);
          default: m_parent.write(t);
        endcase
      endfunction
    endclass

    class data32_imp extends uvm_analysis_imp#(data32_t, dimc_tile_scoreboard);
      function new(string name, dimc_tile_scoreboard parent);
        super.new(name, parent);
      endfunction
      virtual function void write(data32_t t);
        m_parent.write_psin(t);
      endfunction
    endclass

    // Replace default imps with routing imps in connect_phase
    function void connect_phase(uvm_phase phase);
      super.connect_phase(phase);

      // Recreate with routing behavior
      m_output_buffer_env_imp  = null;
      m_feature_buffer_env_imp = null;
      m_kernel_mem_env_imp     = null;
      m_addin_env_imp          = null;
      m_psin_env_imp           = null;

      m_output_buffer_env_imp  = data64_imp::type_id::create("m_output_buffer_env_imp",  this);
      m_feature_buffer_env_imp = data64_imp::type_id::create("m_feature_buffer_env_imp", this);
      m_kernel_mem_env_imp     = data64_imp::type_id::create("m_kernel_mem_env_imp",     this);
      m_addin_env_imp          = data64_imp::type_id::create("m_addin_env_imp",          this);
      m_psin_env_imp           = data32_imp::type_id::create("m_psin_env_imp",           this);

      // Set routing kinds (cast to access kind field)
      begin
        data64_imp out_imp, feat_imp, ker_imp, add_imp;
        if ($cast(out_imp, m_output_buffer_env_imp))  out_imp.kind  = data64_imp::OUT;
        if ($cast(feat_imp, m_feature_buffer_env_imp)) feat_imp.kind = data64_imp::FEATURE;
        if ($cast(ker_imp, m_kernel_mem_env_imp))     ker_imp.kind  = data64_imp::KERNEL;
        if ($cast(add_imp, m_addin_env_imp))          add_imp.kind  = data64_imp::ADDIN;
      end
    endfunction

    function void check_phase(uvm_phase phase);
      super.check_phase(phase);
      if (expected_q.size() != 0) begin
        missing_expected += expected_q.size();
        `uvm_warning(get_type_name(),
                     $sformatf("Simulation ended with %0d expected outputs not observed (missing_expected=%0d).",
                               expected_q.size(), missing_expected))
      end
    endfunction

    function void report_phase(uvm_phase phase);
      super.report_phase(phase);

      `uvm_info(get_type_name(),
                $sformatf({"Scoreboard summary:\n",
                           "  total_compares     = %0d\n",
                           "  matches            = %0d\n",
                           "  mismatches         = %0d\n",
                           "  extra_actual       = %0d\n",
                           "  missing_expected   = %0d\n",
                           "  expected_loaded    = %0d\n",
                           "  expected_remaining = %0d\n"},
                          total_compares, matches, mismatches, extra_actual, missing_expected,
                          expected_loaded, expected_q.size()),
                UVM_NONE)
    endfunction

    // ---- utility string helpers ----
    function string strip_comment(string s);
      int idx1, idx2, idx;
      idx1 = s.find("//");
      idx2 = s.find("#");
      idx = -1;
      if (idx1 >= 0) idx = idx1;
      if (idx2 >= 0) begin
        if (idx < 0 || idx2 < idx) idx = idx2;
      end
      if (idx >= 0) return s.substr(0, idx-1);
      return s;
    endfunction

    function string trim(string s);
      int i, j;
      i = 0;
      j = s.len()-1;
      while (i <= j) begin
        if (s.getc(i) == " " || s.getc(i) == "\t" || s.getc(i) == "\n" || s.getc(i) == "\r")
          i++;
        else
          break;
      end
      while (j >= i) begin
        if (s.getc(j) == " " || s.getc(j) == "\t" || s.getc(j) == "\n" || s.getc(j) == "\r")
          j--;
        else
          break;
      end
      if (j < i) return "";
      return s.substr(i, j);
    endfunction

  endclass : dimc_tile_scoreboard

endpackage : dimc_tile_scoreboard_pkg