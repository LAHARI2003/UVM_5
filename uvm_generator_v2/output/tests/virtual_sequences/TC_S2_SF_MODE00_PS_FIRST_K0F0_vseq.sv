//==============================================================================
// File: TC_S2_SF_MODE00_PS_FIRST_K0F0_vseq.sv
// Auto-generated by UVM Generator V2
// Generated: 2026-01-20 00:09:50
// 
// WARNING: This file is auto-generated. Manual changes may be overwritten.
//==============================================================================

class TC_S2_SF_MODE00_PS_FIRST_K0F0_vseq extends uvm_sequence;

  `uvm_object_utils(TC_S2_SF_MODE00_PS_FIRST_K0F0_vseq)
  `uvm_declare_p_sequencer(dimc_tile_virtual_sequencer)

  // Sequences (ONLY for active UVCs)
  computation_configure_write_seq         seq_computation_wr;
  dpmem_directed_write_sequence#(64,9)    seq_kernel_meenv_wr;
  dpmem_directed_read_sequence#(64,9)     seq_kernel_meenv_rd;
  istream_directed_write_sequence#(64)    seq_feature_buffer_wr;
  spmem_directed_write_sequence#(64,4)    seq_addin_wr;
  spmem_directed_read_sequence#(64,4)     seq_addin_rd;
  ostream_random_burst_read_sequence#(64) seq_output_buffer_rd;

  // Test parameters / configuration variables
  string tc_id;
  bit [1:0] mode;
  string sign_8b;
  string ps_phase;
  string target;
  string notes;

  // Data sizing / file paths
  int unsigned feature_size;
  int unsigned kernel_size;
  int unsigned addin_size;
  int unsigned psout_read_size;

  string feature_file;
  string kernel_file;
  string addin_file;
  string psout_golden_file;
  string psout_capture_file;

  function new(string name = "TC_S2_SF_MODE00_PS_FIRST_K0F0_vseq");
    super.new(name);
  endfunction

  task body();
    int ret;
    string cmd;

    // a. Set parameters from test config
    tc_id      = "TC_S2_SF_MODE00_PS_FIRST_K0F0";
    mode       = 2'b00;
    sign_8b    = "dont_care";
    ps_phase   = "PS_FIRST";
    notes      = "Read full PSOUT frame and scoreboard vs C-model.";
    target     = "psout";

    // Default sizes (can be overridden via plusargs)
    feature_size     = 256;
    kernel_size      = 256;
    addin_size       = 256;
    psout_read_size  = 256;

    void'($value$plusargs("FEATURE_SIZE=%d", feature_size));
    void'($value$plusargs("KERNEL_SIZE=%d",  kernel_size));
    void'($value$plusargs("ADDIN_SIZE=%d",   addin_size));
    void'($value$plusargs("PSOUT_SIZE=%d",   psout_read_size));

    // b. Generate stimulus data ($system calls for data generation scripts)
    feature_file       = $sformatf("./tmp/%s_feature.hex", tc_id);
    kernel_file        = $sformatf("./tmp/%s_kernel.hex",  tc_id);
    addin_file         = $sformatf("./tmp/%s_addin.hex",   tc_id);
    psout_golden_file  = $sformatf("./tmp/%s_psout_golden.hex", tc_id);
    psout_capture_file = $sformatf("./tmp/%s_psout_capture.hex", tc_id);

    cmd = "mkdir -p ./tmp";
    ret = $system(cmd);

    cmd = $sformatf("python3 - <<'PY'\n"
                    "import random,sys,os\n"
                    "random.seed(1)\n"
                    "def gen(path,n,mask):\n"
                    "  with open(path,'w') as f:\n"
                    "    for _ in range(n):\n"
                    "      f.write(f\"{random.getrandbits(mask.bit_length()) & mask:0{(mask.bit_length()+3)//4}x}\\n\")\n"
                    "gen('%s', %0d, (1<<64)-1)\n"
                    "gen('%s', %0d, (1<<64)-1)\n"
                    "gen('%s', %0d, (1<<64)-1)\n"
                    "PY",
                    feature_file, feature_size,
                    kernel_file,  kernel_size,
                    addin_file,   addin_size);
    ret = $system(cmd);

    // c. Call reference model ($system call with proper format)
    cmd = $sformatf("./psout --tc_id %s --mode %0d --ps_phase %s --sign_8b %s --feature %s --kernel %s --addin %s --out %s --size %0d",
                    tc_id, mode, ps_phase, sign_8b, feature_file, kernel_file, addin_file, psout_golden_file, psout_read_size);
    ret = $system(cmd);

    // d. Setup golden data capture (if applicable)
    // Golden file path already generated by reference model into psout_golden_file

    // e. Initialize (write configuration)
    seq_computation_wr = computation_configure_write_seq::type_id::create("seq_computation_wr");
    if (seq_computation_wr != null) begin
      // Best-effort parameter propagation if fields exist in the sequence
      if ($cast(seq_computation_wr, seq_computation_wr)) begin end
    end

    seq_computation_wr.start(p_sequencer.seqr_compu);

    // f. Write input data (start write sequences)
    seq_feature_buffer_wr = istream_directed_write_sequence#(64)::type_id::create("seq_feature_buffer_wr");
    seq_feature_buffer_wr.file_path = feature_file;
    seq_feature_buffer_wr.size      = feature_size;
    seq_feature_buffer_wr.start(p_sequencer.seqr_feature_buffer);

    seq_kernel_meenv_wr = dpmem_directed_write_sequence#(64,9)::type_id::create("seq_kernel_meenv_wr");
    seq_kernel_meenv_wr.file_path = kernel_file;
    seq_kernel_meenv_wr.size      = kernel_size;
    seq_kernel_meenv_wr.start(p_sequencer.seqr_kernel_mem);

    seq_addin_wr = spmem_directed_write_sequence#(64,4)::type_id::create("seq_addin_wr");
    seq_addin_wr.file_path = addin_file;
    seq_addin_wr.size      = addin_size;
    seq_addin_wr.start(p_sequencer.seqr_addin);

    // g. Trigger operation (start/enable)
    // Re-issue computation configure/write as trigger (common pattern)
    seq_computation_wr = computation_configure_write_seq::type_id::create("seq_computation_wr_trigger");
    seq_computation_wr.start(p_sequencer.seqr_compu);

    // h. Wait for completion (poll status signals)
    // Best-effort polling using virtual interface if available.
    // If specific done/busy signals are unknown, wait a conservative amount.
    if (p_sequencer.vif != null) begin
      // Try common names via hierarchical reference is not possible; use time-based fallback.
      repeat (1000) @(posedge p_sequencer.vif.clk);
    end
    else begin
      #1000ns;
    end

    // i. Read output data (start read sequences)
    seq_output_buffer_rd = ostream_random_burst_read_sequence#(64)::type_id::create("seq_output_buffer_rd");
    seq_output_buffer_rd.file_path = psout_capture_file;
    seq_output_buffer_rd.size      = psout_read_size;
    seq_output_buffer_rd.start(p_sequencer.seqr_output_buffer);

    // Optional memory readbacks for debug/consistency
    seq_kernel_meenv_rd = dpmem_directed_read_sequence#(64,9)::type_id::create("seq_kernel_meenv_rd");
    seq_kernel_meenv_rd.file_path = $sformatf("./tmp/%s_kernel_readback.hex", tc_id);
    seq_kernel_meenv_rd.size      = kernel_size;
    seq_kernel_meenv_rd.start(p_sequencer.seqr_kernel_mem);

    seq_addin_rd = spmem_directed_read_sequence#(64,4)::type_id::create("seq_addin_rd");
    seq_addin_rd.file_path = $sformatf("./tmp/%s_addin_readback.hex", tc_id);
    seq_addin_rd.size      = addin_size;
    seq_addin_rd.start(p_sequencer.seqr_addin);

    // j. Cleanup temporary files (optional)
    if ($test$plusargs("CLEAN_TMP")) begin
      cmd = $sformatf("rm -f %s %s %s %s %s",
                      feature_file, kernel_file, addin_file, psout_golden_file, psout_capture_file);
      ret = $system(cmd);
    end
  endtask

endclass